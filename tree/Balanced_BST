#1 Traverse given BST in IN-ORDER and store result in a array, the array will be sorted due in this case (due to IN-ORDER Traversal) 
  Note that this array would be sorted as inorder traversal of BST always produces sorted sequence.
#2 Build a balanced BST from the above created sorted array using the recursive approach

// Inorder traversal to store elements of the tree in sorted order
void storeInorder(Node* root, vector<int>& nodes) {
    if (root == nullptr) 
        return;

    // Traverse the left subtree
    storeInorder(root->left, nodes);

    // Store the node data
    nodes.push_back(root->data);

    // Traverse the right subtree
    storeInorder(root->right, nodes);
}



// Function to build a balanced BST from a sorted array
Node* buildBalancedTree(vector<int>& nodes, int start, int end) 
{    
    // Base case
    if (start > end) 
        return nullptr;

    // Get the middle element and make it the root
    int mid = (start + end) / 2;
    Node* root = new Node(nodes[mid]);

    // Recursively build the left and right subtrees
    root->left = buildBalancedTree(nodes, start, mid - 1);
    root->right = buildBalancedTree(nodes, mid + 1, end);

    return root;
}


// Function to balance a BST
Node* balanceBST(Node* root) {
    vector<int> nodes;

    // Store the nodes in sorted order
    storeInorder(root, nodes);

    // Build the balanced tree from the sorted nodes
    return buildBalancedTree(nodes, 0, nodes.size() - 1);
}
